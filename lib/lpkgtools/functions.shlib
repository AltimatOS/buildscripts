#------
# Author: Gary Greene <greeneg@altimatos.org>
# Copyright 2014-2024 YggdrasilSoft, LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#------

shopt -s expand_aliases

DEBUG=
if [[ "$DEBUG" -eq 1 ]]; then
    set -x
fi

# needed for later
BUILD_STAGE=

LPKG_NAME="part of the Linux Package (LPkg) suite"
LPKG_VERSION="0.4"
LPKG_LICENSE="Apache License, version 2.0"
LPKG_COPYRIGHT="Copyright (C) 2014-2024 YggdrasilSoft, LLC"

SET_NORMAL_MODE=0
SET_BRIGHT_MODE=1
SET_DIM_MODE=2
SET_UNDERLINE_MODE=3
SET_BLINK_MODE=5
SET_REVERSE_MODE=7
SET_HIDDEN_MODE=8

SET_FG_COLOR_RED="\\033[$SET_BRIGHT_MODE;31m"
SET_FG_COLOR_GREEN="\\033[$SET_BRIGHT_MODE;32m"
SET_FG_COLOR_YELLOW="\\033[$SET_BRIGHT_MODE;33m"
SET_FG_COLOR_BLUE="\\033[$SET_BRIGHT_MODE;34m"
SET_FG_COLOR_MAGENTA="\\033[$SET_BRIGHT_MODE;35m"
SET_FG_COLOR_CYAN="\\033[$SET_BRIGHT_MODE;36m"
SET_FG_COLOR_WHITE="\\033[$SET_BRIGHT_MODE;37m"
SET_FG_COLOR_WHITE_WITH_RED_BG="\\033[41m\\033[$SET_BRIGHT_MODE;37m"
SET_COLOR_NORMAL="\\033[$SET_NORMAL_MODE;39m"

#=============================================================================
# CONFFIGURATION
#=============================================================================
# defaults
DEFAULT_PKG_TYPE="pkgsrc"
DEFAULT_PACKAGER="AltimatOS Build System"
DEFAULT_PACKAGER_EMAIL="builds@altimatos.org"
DEFAULT_BUILD_GPG_KEY=""
ROOT=/
TARGET_ROOT=/
PKGROOT=${ROOT}System/src/lpkg
BUILDDIR=$PKGROOT/build
SOURCES=$PKGROOT/sources
BLUEPRINTS=$PKGROOT/blueprints
TMP=$PKGROOT/temp
SRCPKG_ROOT=$PKGROOT/apb/src
BINPKG_ROOT=$PKGROOT/apb/bin
METAPKG_ROOT=$PKGROOT/apb/meta
BUNDLEPKG_ROOT=$PKGROOT/apb/bundle
DB_DIR=${ROOT}System/var/lib/lpkg/db
DB_FILE=$DB_DIR/lpkg.db

function get_metadata_section {
    local file=${1}

    cat $file | grep --color=never -v '#' | sed -n '/^PkgMetadata {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_prep_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Prepare {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_configure_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Configure {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_build_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Build {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_check_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Check {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_install_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Install {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_pkgname {
    local file=${1}

    get_metadata_section $file | yq .Name -o json | jq -r
}

function get_pkgversion {
    local file=${1}

    get_metadata_section $file | yq .Version -o json | jq -r
}

function get_srcurl {
    local file=${1}

    local name=$(get_pkgname $file)
    local version=$(get_pkgversion $file)
    local url=$(get_metadata_section $file | yq .Url -o json | jq -r)

    # hackery to get it to substitute the variables used
    eval echo $url
}

function get_srcs {
    local file=${1}

    local name=$(get_pkgname $file)
    local version=$(get_pkgversion $file)

    local srcs
    typeset -a srcs

    eval echo $(get_metadata_section $file | yq .Sources -o json | jq -r '.[]')
}

function get_srcdir {
    local file=${1}

    get_metadata_section $file | yq .SrcDir -o json | jq -r
}

function get_pkg_requires {
    local file=${1}

    get_metadata_section $file | yq .Requires -o json | jq -r '.[]'
}

function get_pkg_bldrequires {
    local file=${1}

    get_metadata_section $file | yq .BuildRequires -o json | jq -r '.[]'
}

function get_patches {
    local file=${1}

    get_metadata_section $file | yq .Patches -o json | jq -r '.[]'
}

function get_pkg_epoch {
    local file=${1}

    local _epoch=$(get_metadata_section $file | yq .Epoch -o json | jq -r)
    if [[ "$_epoch" == 'null' ]]; then
        say 0
    else
        say $_epoch
    fi
}

function get_summary {
    local file=${1}

    get_metadata_section $file | yq .Summary -o json | jq -r
}

function get_license {
    local file=${1}

    get_metadata_section $file | yq .License -o json | jq -r
}

function get_section {
    local file=${1}

    get_metadata_section $file | yq .Section -o json | jq -r
}

function get_description {
    local file=${1}

    get_metadata_section $file | yq .Description -o json | jq -r
}

function clean() {
    local target=$1

    if [[ -d $target ]]; then
        print_cyan "Removing $target... "
        rm -rf $target
        retval=$?
        if [[ $retval -eq 0 ]]; then
            print_green "OK" && echo
        else
            print_red "FAILED!" && echo
            print_error "ERROR: could not remove directory: $retval" && echo
            exit $retval
        fi
    else
        print_yellow "$target: directory not found, continuing anyway... " && echo
    fi
}

function unpack() {
    local target=$1

    if [[ ! -d $BUILDDIR ]]; then
        mkdir -p $BUILDDIR
    fi
    if [ -f $SOURCES/$target ]; then
        print_cyan "Unpacking sources... ($target) "
        tar xf $SOURCES/$target -C $BUILDDIR/
        retval=$?
        if [[ $retval -eq 0 ]]; then
            print_green "OK" && echo
        else
            print_red "FAILED!" && echo
            print_error "ERROR: could not unpack $target: $retval" && echo
            exit $retval
        fi
    else
        print_error "ERROR: $target: file not found" && echo
        exit -1
    fi
}

function applypatch {

}

function generate_prep_script {
    local file=${1}

    local bld_stage="prep"
    local pkgname=$(get_pkgname $file)
    local pkgversion=$(get_pkgversion $file)

    prep_script=$(mktemp)
    cat << EOF > $prep_script
set -e
set -u
set -o pipefail

BLDSTAGE=$bld_stage

source $SCRIPT_LIB_DIR/functions.shlib

pkgname=\$(get_pkgname $file)
pkgversion=\$(get_pkgversion $file)

declare -a SOURCE
declare -a PATCHES

# assign source list
SOURCE=$(get_srcs $file)

# get patches
PATCHES=$(get_patches $file)

print_white "Building package \${pkgname}, version \${pkgversion}..." && echo
echo

print_white "PHASE: Prepare" && echo
SRCROOT=/srcs
if [[ "$(pwd)" != $SRCROOT ]]; then
    cd $SRCROOT
fi

# get our src_dir
SRC_DIR=$(eval get_srcdir $file)

# clean up previous directories if they existed
clean $SRC_DIR

EOF

    get_prep_section $file >> $prep_script
    chmod 755 $prep_script

    echo $prep_script
}

function print {
    echo -n "$1"
}

function say {
    echo "$1"
}

function print_green() {
    echo -en "${SET_FG_COLOR_GREEN}${1}${SET_COLOR_NORMAL}"
}

function print_cyan() {
    echo -en "${SET_FG_COLOR_CYAN}${1}${SET_COLOR_NORMAL}"
}

function print_error() {
    echo -en "${SET_FG_COLOR_WHITE_WITH_RED_BG}${1}${SET_COLOR_NORMAL}"
}

function print_red() {
    echo -en "${SET_FG_COLOR_RED}${1}${SET_COLOR_NORMAL}"
}

function print_blue() {
    echo -en "${SET_FG_COLOR_BLUE}${1}${SET_COLOR_NORMAL}"
}

function print_yellow() {
    echo -en "${SET_FG_COLOR_YELLOW}${1}${SET_COLOR_NORMAL}"
}

function print_white() {
    echo -en "${SET_FG_COLOR_WHITE}${1}${SET_COLOR_NORMAL}"
}

# load our configuration
cfg_loaded=0
if [[ -d /System ]]; then
    # assume we're on a YggdrasilSoft operating system
    if [[ -f /System/cfg/lpkg/lpkgrc ]]; then
        ((++cfg_loaded))
        source /System/cfg/lpkg/lpkgrc
    fi
else
    if [[ -d /etc/lpkg ]]; then
        if [[ -f /etc/lpkg/lpkgrc ]]; then
            ((++cfg_loaded))
            source /etc/lpkg/lpkgrc
        fi
    fi
fi
if [[ -f $HOME/.lpkgrc ]]; then
    # load our overrides if they exist
    ((++cfg_loaded))
    source $HOME/.lpkgrc
fi
if [[ ! $cfg_loaded -gt 0 ]]; then
    print_yellow "WARNING: Cannot find configuration. Using defaults" && echo
fi

