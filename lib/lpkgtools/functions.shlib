#------
# Author: Gary Greene <greeneg@altimatos.org>
# Copyright 2014-2024 YggdrasilSoft, LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#------

shopt -s expand_aliases

DEBUG=
if [[ "$DEBUG" -eq 1 ]]; then
    set -x
fi

# needed for later
BUILD_STAGE=

LPKG_NAME="part of the Linux Package (LPkg) suite"
LPKG_VERSION="0.4"
LPKG_LICENSE="Apache License, version 2.0"
LPKG_COPYRIGHT="Copyright (C) 2014-2024 YggdrasilSoft, LLC"

SET_NORMAL_MODE=0
SET_BRIGHT_MODE=1
SET_DIM_MODE=2
SET_UNDERLINE_MODE=3
SET_BLINK_MODE=5
SET_REVERSE_MODE=7
SET_HIDDEN_MODE=8

SET_FG_COLOR_RED=$(echo -e "bold\nsetaf 1" | tput -S)
SET_FG_COLOR_GREEN=$(echo -e "bold\nsetaf 2" | tput -S)
SET_FG_COLOR_YELLOW=$(echo -e "bold\nsetaf 3" | tput -S)
SET_FG_COLOR_BLUE=$(echo -e "bold\nsetaf 4" | tput -S)
SET_FG_COLOR_MAGENTA=$(echo -e "bold\nsetaf 5"| tput -S)
SET_FG_COLOR_CYAN=$(echo -e "bold\nsetaf 6" | tput -S)
SET_FG_COLOR_WHITE=$(echo -e "bold\nsetaf 7" | tput -S)
SET_FG_COLOR_WHITE_WITH_RED_BG="\\033[41m\\033[$SET_BRIGHT_MODE;37m"
SET_COLOR_NORMAL=$(tput sgr0)

#=============================================================================
# CONFFIGURATION
#=============================================================================
# defaults
DEFAULT_PKG_TYPE="pkgsrc"
DEFAULT_PACKAGER="AltimatOS Build System"
DEFAULT_PACKAGER_EMAIL="builds@altimatos.org"
DEFAULT_BUILD_GPG_KEY=""
ROOT=/
TARGET_ROOT=/
PKGROOT=${ROOT}System/src/lpkg
BUILDDIR=$PKGROOT/build
SOURCES=$PKGROOT/sources
BLUEPRINTS=$PKGROOT/blueprints
TMP=$PKGROOT/temp
SRCPKG_ROOT=$PKGROOT/apb/src
BINPKG_ROOT=$PKGROOT/apb/bin
METAPKG_ROOT=$PKGROOT/apb/meta
BUNDLEPKG_ROOT=$PKGROOT/apb/bundle
DB_DIR=${ROOT}System/var/lib/lpkg/db
DB_FILE=$DB_DIR/lpkg.db

# end of defaults

function get_metadata_section {
    local file=${1}

    cat $file | grep --color=never -v '#' | sed -n '/^PkgMetadata {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_prep_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Prepare {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_configure_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Configure {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_build_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Build {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_check_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Check {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_install_section {
    local file=${1}

    cat $file | grep -v '#'| sed -n '/^Install {/,/^}$/p' | tail -n+2 | head -n-1
}

function get_pkgname {
    local file=${1}

    get_metadata_section $file | yq .Name -o json | jq -r
}

function get_pkgversion {
    local file=${1}

    get_metadata_section $file | yq .Version -o json | jq -r
}

function get_srcurl {
    local file=${1}

    local name=$(get_pkgname $file)
    local version=$(get_pkgversion $file)
    local url=$(get_metadata_section $file | yq .Url -o json | jq -r)

    # hackery to get it to substitute the variables used
    eval echo $url
}

function get_srcs {
    local file=${1}

    local name=$(get_pkgname $file)
    local version=$(get_pkgversion $file)

    local srcs
    typeset -a srcs

    eval echo $(get_metadata_section $file | yq .Sources -o json | jq -r '.[]')
}

function get_srcdir {
    local file=${1}

    get_metadata_section $file | yq .SrcDir -o json | jq -r
}

function get_pkg_requires {
    local file=${1}

    get_metadata_section $file | yq .Requires -o json | jq -r '.[]'
}

function get_pkg_bldrequires {
    local file=${1}

    get_metadata_section $file | yq .BuildRequires -o json | jq -r '.[]'
}

function get_patches {
    local file=${1}

    get_metadata_section $file | yq .Patches -o json | jq -r '.[]'
}

function get_pkg_epoch {
    local file=${1}

    local _epoch=$(get_metadata_section $file | yq .Epoch -o json | jq -r)
    if [[ "$_epoch" == 'null' ]]; then
        say 0
    else
        say $_epoch
    fi
}

function get_summary {
    local file=${1}

    get_metadata_section $file | yq .Summary -o json | jq -r
}

function get_license {
    local file=${1}

    get_metadata_section $file | yq .License -o json | jq -r
}

function get_section {
    local file=${1}

    get_metadata_section $file | yq .Section -o json | jq -r
}

function get_description {
    local file=${1}

    get_metadata_section $file | yq .Description -o json | jq -r
}

function clean {
    local target=${1}
    local blueprint=${blueprint}

    local name=$(get_pkgname $blueprint)
    local version=$(get_pkgversion $blueprint)

    evald_target=$(eval echo $target)
    if [[ -d $evald_target ]]; then
        # msg=$(eval print_cyan "Removing $evald_target... ")
        printf "%-74s" "${SET_FG_COLOR_CYAN}Removing $evald_target...."
        rm -rf $evald_target
        retval=$?
        if [[ $retval -eq 0 ]]; then
            print_green "OK" && echo
        else
            print_red "FAILED!" && echo
            print_error "ERROR: Could not remove file or directory: $retval" && echo
            exit $retval
        fi
    else
        print_yellow "WARNING: $evald_target: File or directory not found, continuing anyway... " && echo
    fi
}

function get_file_type {
    local target=${1}

    file -bi $target | cut -d';' -f1
}

function unpack {
    local blueprint=${blueprint}
    local sources=${SOURCES}

    declare -a archives=$(get_srcs $blueprint)

    local target=
    local OPTSTRTRING=":s:"
    while getopts $OPTSTRTRING opt; do
        case $opt in
            s)
                target="${archives[$OPTARG]}"
                if [[ ! -f $sources/$target ]]; then
                    print_error "ERROR: $sources/$target: File not found! Exiting" && echo
                    exit 2
                fi
            ;;
            :)
                print_error "ERROR: Invalid syntax! Exiting" && echo
                print_error "       See documentation on the \`unpack\` function" && echo
                print_error "       syntax: unpack -f \$FILENAME" && echo
                exit 22
            ;;
            ?)
                print_error "ERROR: Invalid option! Exiting" && echo
                print_error "       See documentation on the \`unpack\` function" && echo
                print_error "       syntax: unpack -f \$FILENAME" && echo
                exit 22
            ;;
        esac
    done

    if [[ ! -d $BUILDDIR ]]; then
        install -d -m 755 $BUILDDIR
    fi

    # what type of archive are we dealing with?
    mime_type=$(get_file_type $target)

    if [[ -f $sources/$target ]]; then
        printf "%-74s" "${SET_FG_COLOR_CYAN}Unpacking sources... ($target)"
        case "$mime_type" in
            'application/x-xz')
                tar xJf $sources/$target -C $BUILDDIR/
                retval=$?
            ;;
            'application/x-gzip')
                tar xzf $sources/$target -C $BUILDDIR/
                retval=$?
            ;;
            'application/x-bzip2')
                tar xjf $sources/$target -C $BUILDDIR/
                retval=$?
            ;;
            'application/zip')
                unzip -qq $sources/$target -d $BUILDDIR/
                retval=$?
            ;;
            *)
                print_error "\nERROR: Unknown archive type! Exiting" && echo
                exit 1
            ;;
        esac
        if [[ $retval -eq 0 ]]; then
            print_green "OK" && echo
        else
            print_red "FAILED!" && echo
            print_error "ERROR: could not unpack $target: $retval" && echo
            exit $retval
        fi
    else
        print_error "ERROR: $target: file not found" && echo
        exit -1
    fi
}

function applypatch {
    local blueprint=${blueprint}

    local pbackup=0
    local patchlvl=0
    local verbose=0

    local name=$(get_pkgname $blueprint)
    local version=$(get_pkgversion $blueprint)
    local src_dir=$(eval echo $(get_srcdir $blueprint))

    local bk_name=
    local patch_level=

    optvars=$(getopt -o b:f:p:v -- "$@")
    eval set -- "$optvars"

    while true; do
        case "$1" in
            -b)
                pbackup=1
                bk_name=$2
                shift 2
            ;;
            -f)
                patch_file=$2
                if [[ ! -f $SOURCES/$patch_file ]]; then
                    print_error "ERROR: $SOURCES/$patch_file: File not found! Exiting" && echo
                    exit 2
                fi
                shift 2
            ;;
            -p)
                patchlvl=1
                patch_level=$2
                shift 2
            ;;
            -v)
                verbose=1
            ;;
            --)
                shift
                break
            ;;
            *)
                print_error "ERROR: Invalid option! Exiting" && echo
                print_error "       See documentation on the \`applypatch\` function" && echo
                print_error "       syntax: unpack -f \$FILENAME" && echo
                exit 22
            ;;
        esac
    done

    printf "%-74s" "${SET_FG_COLOR_CYAN}Patching sources...  ($patch_file)..."
    local flags=""
    if [[ $patchlvl -eq 0 ]]; then
        flags="Nlp1"
    else
        flags="Nlp${patch_level}"
    fi
    if [[ $pbackup -eq 1 ]]; then
        flags="$flags -b $bk_name"
    fi
    retval=0
    if [[ $verbose -eq 0 ]]; then
        pushd $src_dir >/dev/null
        patch -${flags} -i $SOURCES/$patch_file > /dev/null || retval=$?
        popd >/dev/null
    else
        pushd $src_dir >/dev/null
        patch -${flags} -i $SOURCES/$patch_file || retval=$?
        popd >/dev/null
    fi
    if [[ $retval -eq 0 ]]; then
        print_green "OK" && echo
    else
        print_red "FAILED!" && echo
        print_error "ERROR: $SOURCES/$patch_file: cannot patch sources. Try applying manually to determine problem." && echo
        exit $retval
    fi
}

function generate_prep_script {
    local file=${1}

    local bld_stage="prep"
    local pkgname=$(get_pkgname $file)
    local pkgversion=$(get_pkgversion $file)

    mkdir -p /tmp/lpkg
    prep_script=$(mktemp -p /tmp/lpkg)
    print_cyan "Generating prepare script: $prep_script" >&2 && echo >&2
    cat << EOF > $prep_script
set -e
set -u
set -o pipefail

BLDSTAGE=$bld_stage

source $SCRIPT_LIB_DIR/functions.shlib

blueprint=$file
name=\$(get_pkgname $file)
version=\$(get_pkgversion $file)

declare -a SOURCE
declare -a PATCHES

# assign source list
SOURCE=\$(get_srcs $file)

# get patches
PATCHES=\$(get_patches $file)

print_white "EXECUTING PHASE: prep" && echo
if [[ "$(pwd)" != \$SOURCES ]]; then
    retval=0
    cd \$SOURCES || retval=\$?
    if [[ \$retval -ne 0 ]]; then
        print_error "ERROR: Directory '$SOURCES' not found! Exiting" && echo
        exit 2
    fi
fi

# get our src_dir
SRC_DIR=\$(eval echo \$(get_srcdir $file))

# clean up previous directories if they existed
clean \$SRC_DIR

EOF

    get_prep_section $file >> $prep_script
    chmod 755 $prep_script

    echo $prep_script
}

function generate_config_script {
    local file=${1}

    local bld_stage="config"
    local pkgname=$(get_pkgname $file)
    local pkgversion=$(get_pkgversion $file)

    mkdir -p /tmp/lpkg
    config_script=$(mktemp -p /tmp/lpkg)
    print_cyan "Generating configure script: $config_script" >&2 && echo >&2
    cat << EOF > $config_script
set -e
set -u
set -o pipefail

BLDSTAGE=$bld_stage

source $SCRIPT_LIB_DIR/functions.shlib

blueprint=$file
name=\$(get_pkgname $file)
version=\$(get_pkgversion $file)

print_white "EXECUTING PHASE: config" && echo
if [[ "$(pwd)" != \$SOURCES ]]; then
    retval=0
    cd \$SOURCES || retval=\$?
    if [[ \$retval -ne 0 ]]; then
        print_error "ERROR: Directory '$SOURCES' not found! Exiting" && echo
        exit 2
    fi
fi

# get our src_dir
SRC_DIR=\$(eval echo \$(get_srcdir $file))

pushd \$SRC_DIR >/dev/null
EOF

    get_configure_section $file >> $config_script
    cat << EOF >> $config_script
popd >/dev/null
EOF
    chmod 755 $config_script

    echo $config_script
}

function generate_build_script {
    local file=${1}

    local bld_stage="build"
    local pkgname=$(get_pkgname $file)
    local pkgversion=$(get_pkgversion $file)

    mkdir -p /tmp/lpkg
    build_script=$(mktemp -p /tmp/lpkg)
    print_cyan "Generating build script: $build_script" >&2 && echo >&2
    cat << EOF > $build_script
set -e
set -u
set -o pipefail

BLDSTAGE=$bld_stage

source $SCRIPT_LIB_DIR/functions.shlib

blueprint=$file
name=\$(get_pkgname $file)
version=\$(get_pkgversion $file)

print_white "EXECUTING PHASE: build" && echo
if [[ "$(pwd)" != \$SOURCES ]]; then
    retval=0
    cd \$SOURCES || retval=\$?
    if [[ \$retval -ne 0 ]]; then
        print_error "ERROR: Directory '$SOURCES' not found! Exiting" && echo
        exit 2
    fi
fi

# get our src_dir
SRC_DIR=\$(eval echo \$(get_srcdir $file))

pushd \$SRC_DIR >/dev/null
EOF

    get_build_section $file >> $build_script
    cat << EOF >> $build_script
popd >/dev/null
EOF
    chmod 755 $build_script

    echo $build_script
}

function generate_check_script {
    true
}

function print {
    echo -n "$1"
}

function say {
    echo "$1"
}

function print_green() {
    echo -en "${SET_FG_COLOR_GREEN}${1}${SET_COLOR_NORMAL}"
}

function print_cyan() {
    echo -en "${SET_FG_COLOR_CYAN}${1}${SET_COLOR_NORMAL}"
}

function print_error() {
    echo -en "${SET_FG_COLOR_WHITE_WITH_RED_BG}${1}${SET_COLOR_NORMAL}"
}

function print_red() {
    echo -en "${SET_FG_COLOR_RED}${1}${SET_COLOR_NORMAL}"
}

function print_blue() {
    echo -en "${SET_FG_COLOR_BLUE}${1}${SET_COLOR_NORMAL}"
}

function print_yellow() {
    echo -en "${SET_FG_COLOR_YELLOW}${1}${SET_COLOR_NORMAL}"
}

function print_white() {
    echo -en "${SET_FG_COLOR_WHITE}${1}${SET_COLOR_NORMAL}"
}

# load our configuration
cfg_loaded=0
if [[ -d /System ]]; then
    # assume we're on a YggdrasilSoft operating system
    if [[ -f /System/cfg/lpkg/lpkgrc ]]; then
        ((++cfg_loaded))
        source /System/cfg/lpkg/lpkgrc
    fi
else
    if [[ -d /etc/lpkg ]]; then
        if [[ -f /etc/lpkg/lpkgrc ]]; then
            ((++cfg_loaded))
            source /etc/lpkg/lpkgrc
        fi
    fi
fi
if [[ -f $HOME/.lpkgrc ]]; then
    # load our overrides if they exist
    ((++cfg_loaded))
    source $HOME/.lpkgrc
fi
if [[ ! $cfg_loaded -gt 0 ]]; then
    print_yellow "WARNING: Cannot find configuration. Using defaults" >&2 && echo >&2
fi

